package wait

import "sync"

type Group struct {
	wg    sync.WaitGroup
	mutex sync.Mutex
	errs  MultiError
	done  chan struct{}
}

// Go runs the provided routine in a function until it returns
func (wg *Group) Go(cb func()) {
	wg.wg.Add(1)
	go func() {
		cb()
		wg.wg.Done()
	}()
}

// Run the provided function in a goroutine and collect errors if any.
// It is advisable to avoid sharing the Group instance across multiple Run() and Wait() calls,
// as the Group aggregates all errors generated by Run() into a single error. This approach ensures
// clean and predictable error handling in concurrent operations.
func (wg *Group) Run(callBack func() error) {
	wg.wg.Add(1)
	go func() {
		err := callBack()
		if err == nil {
			wg.wg.Done()
			return
		}
		wg.mutex.Lock()
		wg.errs = append(wg.errs, err)
		wg.wg.Done()
		wg.mutex.Unlock()
	}()
}

// Loop runs a goroutine in a loop continuously, if the callBack returns false the loop is broken
func (wg *Group) Loop(callBack func() bool) {
	wg.wg.Add(1)
	go func() {
		for {
			if !callBack() {
				wg.wg.Done()
				break
			}
		}
	}()
}

// Until runs a function in a routine continuously. If the callBack returns false the loop is broken.
// `Until()` differs from `Loop()` in that if the `Stop()` is called on the Group
// the `done` channel is closed. Implementations of the callBack function can listen
// for the close to indicate a stop was requested.
func (wg *Group) Until(cb func(done chan struct{}) bool) {
	wg.mutex.Lock()
	if wg.done == nil {
		wg.done = make(chan struct{})
	}
	wg.mutex.Unlock()

	wg.wg.Add(1)
	go func() {
		for {
			if !cb(wg.done) {
				wg.wg.Done()
				break
			}
		}
	}()
}

// Stop closes the done channel passed into `Until()` calls and waits for
// the `Until()` callBack to return false.
func (wg *Group) Stop() {
	wg.mutex.Lock()
	defer wg.mutex.Unlock()

	if wg.done != nil {
		close(wg.done)
	}
	wg.wg.Wait()
	wg.done = nil
}

// Wait for all the routines to complete and return any errors collected
func (wg *Group) Wait() error {
	wg.wg.Wait()

	wg.mutex.Lock()
	defer func() {
		wg.errs = nil
		wg.mutex.Unlock()
	}()

	if len(wg.errs) == 0 {
		return nil
	}
	return wg.errs
}
